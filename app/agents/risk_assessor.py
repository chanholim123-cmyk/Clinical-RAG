"""
NG12 Cancer Risk Assessor Agent (Part 1).

This module implements the core clinical decision support agent that assesses
cancer risk by cross-referencing patient clinical data against NICE NG12
guidelines on suspected cancer recognition and referral.
"""

import json
import logging
from typing import Any, Dict, List, Optional

try:
    import vertexai
    from vertexai.generative_models import (
        GenerativeModel,
        Tool,
        FunctionDeclaration,
        GoogleSearch,
    )
except ImportError as e:
    raise ImportError(
        "vertexai package is required. Install with: pip install google-cloud-aiplatform"
    ) from e

from app.tools.patient_lookup import (
    get_patient_record,
    list_patient_ids,
    PATIENT_TOOLS
)
from app.tools.guideline_lookup import (
    search_ng12_guidelines,
    GUIDELINE_TOOLS
)

logger = logging.getLogger(__name__)

# System prompt for the risk assessor
RISK_ASSESSOR_SYSTEM_PROMPT = """You are an NG12 Clinical Decision Support Agent. Your role is to assess cancer risk for a given patient by cross-referencing their clinical data against the NICE NG12 guidelines on suspected cancer recognition and referral.

## Your Process (follow strictly)

1. RETRIEVE: Call `get_patient_record` with the provided Patient ID to obtain demographics, smoking history, symptoms, and symptom duration.
2. SEARCH: For EACH symptom the patient presents, call `search_ng12_guidelines` with a targeted query combining:
   - The specific symptom name
   - The patient's age and gender context
   - Relevant risk factors (e.g., smoking history)
   Example: "persistent cough shortness of breath lung cancer referral aged 45 ex-smoker"
3. REASON: Cross-reference the patient's full clinical picture against ALL retrieved guideline passages. Evaluate:
   - Does the patient meet age thresholds specified in the guidelines?
   - Does the symptom combination match any referral criteria?
   - Does symptom duration meet "persistent" thresholds?
   - Do risk factors (smoking, gender) modify the recommendation?
   - Could the symptoms indicate multiple possible cancer sites?
4. CLASSIFY the urgency using ONLY these NG12 categories:
   - "Suspected cancer pathway referral" (2-week wait pathway)
   - "Very urgent referral" (within 48 hours)
   - "Urgent investigation" (within 2 weeks)
   - "Non-urgent referral"
   - "Consider investigation / safety netting"
   - "No NG12 criteria met - standard care"

## NG12 Key Terminology
- "Unexplained": symptoms not yet diagnosed after initial primary care assessment
- "Persistent": continuing beyond a period normally associated with self-limiting problems
- "Suspected cancer pathway referral": diagnosis or rule-out within 28 days of GP referral

## Output Format (strict JSON)
{
  "patient_id": "...",
  "patient_summary": {
    "name": "...",
    "age": ...,
    "gender": "...",
    "smoking_history": "...",
    "presenting_symptoms": [...],
    "symptom_duration_days": ...
  },
  "risk_assessment": {
    "identified_cancer_risks": [
      {
        "cancer_type": "...",
        "matching_criteria": "Brief description of which NG12 criteria are met",
        "recommendation_ids": ["1.1.1", "1.1.2"]
      }
    ],
    "overall_urgency": "One of the categories above",
    "referral_recommendation": "Specific recommended action"
  },
  "reasoning": "Step-by-step explanation of clinical reasoning linking patient data to guideline criteria",
  "citations": [
    {
      "source": "NG12 PDF",
      "page": ...,
      "section": "...",
      "recommendation_id": "...",
      "excerpt": "Relevant passage text"
    }
  ]
}

## Safety Rules
- NEVER invent criteria not found in the retrieved guidelines.
- If the retrieved passages do not clearly support a referral, state "Insufficient evidence for NG12-based referral" and recommend safety netting.
- Always err on the side of caution: if criteria are borderline met, recommend the more urgent pathway.
- This is a decision SUPPORT tool. Always include: "This assessment is generated by an AI system and must be reviewed by a qualified healthcare professional."
"""


class CancerRiskAssessor:
    """
    NG12 Cancer Risk Assessment Agent.

    This agent provides clinical decision support by assessing patient cancer
    risk against NICE NG12 guidelines. It uses function calling to retrieve
    patient records and search clinical guidelines, then synthesizes the
    information into a structured risk assessment with recommendations.
    """

    def __init__(self, project_id: Optional[str] = None, location: str = "us-central1"):
        """
        Initialize the Cancer Risk Assessor.

        Args:
            project_id: GCP project ID. If not provided, uses default from
                       environment (GOOGLE_CLOUD_PROJECT).
            location: GCP region (default: us-central1)

        Raises:
            ValueError: If project_id cannot be determined
        """
        self.project_id = project_id
        self.location = location

        # Initialize Vertex AI
        try:
            if project_id:
                vertexai.init(project=project_id, location=location)
        except Exception as e:
            logger.warning(f"Could not initialize vertexai: {e}")

        # Initialize the model with function calling
        self.model = GenerativeModel(
            model_name="gemini-1.5-pro",
            system_instruction=RISK_ASSESSOR_SYSTEM_PROMPT
        )

        # Prepare tools for function calling
        self.tools = self._prepare_tools()

    def _prepare_tools(self) -> List[Tool]:
        """
        Prepare Vertex AI Tool objects from tool definitions.

        Returns:
            List of Tool objects configured for function calling
        """
        tools = []

        # Add patient lookup tools
        for tool_def in PATIENT_TOOLS:
            tools.append(self._create_tool_from_definition(tool_def))

        # Add guideline lookup tools
        for tool_def in GUIDELINE_TOOLS:
            tools.append(self._create_tool_from_definition(tool_def))

        return tools

    @staticmethod
    def _create_tool_from_definition(tool_def: Dict[str, Any]) -> Tool:
        """
        Create a Vertex AI Tool object from a tool definition dict.

        Args:
            tool_def: Tool definition with name, description, parameters

        Returns:
            Configured Tool object
        """
        func_decl = FunctionDeclaration(
            name=tool_def["name"],
            description=tool_def["description"],
            parameters=tool_def["parameters"]
        )
        return Tool(function_declarations=[func_decl])

    def _execute_function(self, function_name: str, function_args: Dict[str, Any]) -> Any:
        """
        Execute a function by name with the given arguments.

        Args:
            function_name: Name of the function to execute
            function_args: Dictionary of function arguments

        Returns:
            Function result (varies by function)

        Raises:
            ValueError: If function is not recognized
        """
        if function_name == "get_patient_record":
            return get_patient_record(function_args.get("patient_id", ""))

        elif function_name == "search_ng12_guidelines":
            return search_ng12_guidelines(
                query=function_args.get("query", ""),
                top_k=function_args.get("top_k", 5)
            )

        else:
            raise ValueError(f"Unknown function: {function_name}")

    def assess(self, patient_id: str) -> Dict[str, Any]:
        """
        Assess cancer risk for a given patient.

        This method orchestrates the assessment process:
        1. Sends patient ID and assessment request to Gemini
        2. Handles function calling loop (tool calls → results → next response)
        3. Parses the final structured response
        4. Returns a comprehensive assessment with reasoning and citations

        Args:
            patient_id: The patient ID to assess (e.g., "PT-101")

        Returns:
            Dictionary with assessment results including:
                - patient_id: The assessed patient ID
                - patient_summary: Demographics and presenting symptoms
                - risk_assessment: Cancer risks and recommendations
                - urgency_level: NG12 urgency category
                - referral_recommendation: Specific action recommended
                - reasoning: Clinical reasoning explanation
                - citations: Referenced guideline passages
                - error: (optional) Error message if assessment failed

        Example:
            >>> assessor = CancerRiskAssessor(project_id="my-project")
            >>> result = assessor.assess("PT-101")
            >>> print(f"Urgency: {result['risk_assessment']['overall_urgency']}")
            >>> print(f"Recommendation: {result['risk_assessment']['referral_recommendation']}")
        """
        try:
            # Initial user message
            user_message = f"Please assess cancer risk for patient ID: {patient_id}"

            # Start conversation
            conversation_history = []
            response = self.model.generate_content(
                [user_message],
                tools=self.tools,
                stream=False
            )

            # Function calling loop
            max_iterations = 10
            iteration = 0

            while iteration < max_iterations:
                iteration += 1
                logger.debug(f"Assessment iteration {iteration}")

                # Check if we have function calls to process
                function_calls = []
                for part in response.candidates[0].content.parts:
                    if hasattr(part, "function_call"):
                        function_calls.append(part.function_call)

                if not function_calls:
                    # No more function calls, we have the final response
                    break

                # Process function calls
                function_results = []
                for fc in function_calls:
                    logger.debug(f"Executing function: {fc.name}")
                    try:
                        result = self._execute_function(
                            fc.name,
                            dict(fc.args)
                        )
                        function_results.append({
                            "name": fc.name,
                            "result": result
                        })
                    except Exception as e:
                        logger.error(f"Error executing function {fc.name}: {e}")
                        function_results.append({
                            "name": fc.name,
                            "error": str(e)
                        })

                # Add function results to conversation and get next response
                conversation_history.append({
                    "role": "user",
                    "content": user_message
                })
                conversation_history.append({
                    "role": "assistant",
                    "content": response.candidates[0].content
                })

                # Send function results back to model
                response = self.model.generate_content(
                    conversation_history + [
                        {
                            "role": "user",
                            "parts": [
                                {
                                    "function_response": {
                                        "name": fr["name"],
                                        "response": fr.get("result", {"error": fr.get("error")})
                                    }
                                }
                                for fr in function_results
                            ]
                        }
                    ],
                    tools=self.tools,
                    stream=False
                )

            # Extract final text response
            final_response_text = ""
            for part in response.candidates[0].content.parts:
                if hasattr(part, "text"):
                    final_response_text += part.text

            # Parse the JSON response
            try:
                # Find JSON in the response
                json_start = final_response_text.find("{")
                json_end = final_response_text.rfind("}") + 1

                if json_start >= 0 and json_end > json_start:
                    json_str = final_response_text[json_start:json_end]
                    assessment = json.loads(json_str)
                    assessment["error"] = False
                    return assessment
                else:
                    return {
                        "error": True,
                        "message": "Model did not return structured JSON response",
                        "raw_response": final_response_text
                    }

            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse assessment JSON: {e}")
                return {
                    "error": True,
                    "message": f"Failed to parse assessment response: {str(e)}",
                    "raw_response": final_response_text
                }

        except Exception as e:
            logger.error(f"Assessment failed: {e}", exc_info=True)
            return {
                "error": True,
                "message": f"Assessment failed: {str(e)}",
                "patient_id": patient_id
            }
